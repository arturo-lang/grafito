#!/usr/bin/env arturo
;========================================================
; Grafito
;
; SQLite-based Graph Database
; in Arturo
;--------------------------------------------------------
;; name: grafito
;; version: 0.2.8
;; author: drkameleon
;; website: Â« https://github.com/arturo-lang/grafito
;; category: database
;========================================================

;--------------------------
; The main library
;--------------------------

Grafito: #[
    ; version
    Version: 0.2.8

    ; configuration
    Debug?: false
    verbose?: true
    caseSensitive?: true
]

graph: function [
    dbpath :string :null
    body :block
][
    ;; description: Â« initiate a new graph environment with given name and body
    ;; options: [
    ;;      create: Â« recreate database from scratch, even if it exists
    ;;      case: Â« queries should be case-sensitive
    ;;      verbose: Â« show messages regarding database operations
    ;; ]
    ;; returns: :any
    ;; example: {
    ;;      graph "mydb" [
    ;;          ; do sth with this graph database
    ;;      ]
    ;;      ;;;;
    ;;      ; in memory database
    ;;      graph Ã¸ [
    ;;          ; do sth with this graph database
    ;;      ]
    ;; }

    ;==========================================
    ; CONSTANTS
    ;==========================================

    ; Global SQL scripts

    schemaSQL:                  split.by:";" read "sql/schema.sql"

    createNodeSQL:              read "sql/procs/createNode.sql"
    updateNodeSQL:              read "sql/procs/updateNode.sql"
    updateNodePropertiesSQL:    read "sql/procs/updateNodeProperties.sql"
    deleteNodeSQL:              read "sql/procs/deleteNode.sql"
    deleteNodeEdgesSQL:         read "sql/procs/deleteNodeEdges.sql"
    getNodeSQL:                 read "sql/procs/getNode.sql"
    getRelatedNodesSQL:         read "sql/procs/getRelatedNodes.sql"
    getMaxNodeIdSQL:            read "sql/procs/getMaxNodeId.sql"

    createEdgeSQL:              read "sql/procs/createEdge.sql"
    updateEdgeSQL:              read "sql/procs/updateEdge.sql"
    deleteEdgeSQL:              read "sql/procs/deleteEdge.sql"
    deleteEdgeByIdSQL:          read "sql/procs/deleteEdgeById.sql"

    fetchNodesSQL:              read "sql/procs/fetchNodes.sql"
    fetchNodesWithEdgesSQL:     read "sql/procs/fetchNodes.withEdges.sql"

    countNodesSQL:              read "sql/procs/countNodes.sql"
    countEdgesSQL:              read "sql/procs/countEdges.sql"

    ; Global SQL filters

    hasEdgeFilter:              read "sql/filters/hasEdge.sql"
    hasPropertyFilter:          read "sql/filters/hasProperty.sql"
    edgeWithTargetFilter:       read "sql/filters/edgeWithTarget.sql"
    propertyWithValueFilter:    read "sql/filters/propertyWithValue.sql"

    ; Global SQL pragmas

    caseInsensitiveLikePragma:  read "sql/pragmas/caseInsensitiveLike.sql"
    caseSensitiveLikePragma:    read "sql/pragmas/caseSensitiveLike.sql"

    ; Global UI template

    app: read "ui/index.html"

    ; Color library
    ; for graph nodes

    colorPalette: as.data "ui/palettes/viridis.art"
    ; [
    ;     'blue 'blueviolet 'brown 'cadetblue 'chocolate 'crimson 'darkblue 'darkgreen 
    ;     'darkmagenta 'darkorchid 'darkred 'darkslategray 'dodgerblue 'green 'indigo 
    ;     'maroon 'mediumpurple 'midnightblue 'olive 'orange 'orangered 'peru 'purple 
    ;     'seagreen 'steelblue 'teal
    ; ]

    ;==========================================
    ; HELPERS
    ;==========================================

    ;
    ; Perform query
    ;--------------------------

    performQuery: function [ctx, qu, params][
        if and? [Grafito\Debug?][null? attr 'noDebug] [
            context: to :string ctx
            prepend: " | "
            print color.bold #gray ">: " ++ context
            
            queryString: qu
            if block? qu [
                queryString: join.with:"\n" qu
            ]

            print color #gray prepend ++ join.with:"\n"++prepend split.lines queryString

            print ""
        ]
        if? not? null? params [
            query db .with: params qu
        ]
        else [
            query db qu
        ]
    ]

    ;
    ; Print message
    ;--------------------------

    printDebug: function [msg][
        print color #cyan ":: " ++ msg
    ]

    ;
    ; Format size
    ;--------------------------

    formatSize: function [sz][
        nz: new sz
        if nz < 1024 -> return @[nz, "B"]
        if nz < 1024*1024 -> return @[to :floating to :string .format: ".2f" nz//1024, "KB"]
        if nz < 1024*1024*1024 -> return @[to :floating to :string .format: ".2f" (nz//1024)//1024, "MB"]
        if nz < 1024*1024*1024*1024 -> return @[to :floating to :string .format: ".2f" ((nz//1024)//1024)//1024, "GB"]
        return @[]
    ]

    ;
    ; Get db analytics
    ;--------------------------

    analytics: function [][
        nodeCount: to :integer first first performQuery 'analytics countNodesSQL Ã¸
        edgeCount: to :integer first first performQuery 'analytics countEdgesSQL Ã¸
        avgDegree: edgeCount // nodeCount

        filename: dbPath
        filesize: 0

        if not? empty? filename [
            prefilesize: formatSize volume filename
            filesize: #[
                number: first prefilesize
                units: last prefilesize
            ]
            filename: relative filename
        ]

        prememory: formatSize process\memory\occupied
        mem: #[
            number: first prememory
            units: last prememory
        ]

        return #[
            database: #[
                nodes: nodeCount
                edges: edgeCount
                degree: to :floating to :string .format: ".2f" avgDegree
            ]
            memory: mem
            disk: #[
                path: filename
                size: filesize
            ]
        ]
    ]

    idealForeground: function [back][
        rgb1: extract back
        L1: sum @[0.2126*rgb1\red 0.7152*rgb1\green 0.0722*rgb1\blue]
        rgb2: extract #white
        L2: sum @[0.2126*rgb2\red 0.7152*rgb2\green 0.0722*rgb2\blue]

        print ["L1:" L1]
        print ["L2:" L2]

        ratio: (L2 + 0.05) // (L1 + 0.05)

        print ["Ratio:" ratio]

        return #white
    ]

    styleNode: function [nodeId, nodeTag, nodeProps][
        if not? key? nodeColors nodeTag [
            nodeColor: sample colorPalette
            print [">> Picked:" nodeColor "for:" nodeTag]
            'colorPalette -- nodeColor
            set nodeColors nodeTag nodeColor
        ]

        bg: to :string nodeColors\[nodeTag]
        fg: to :string idealForeground nodeColors\[nodeTag]

        nodeLabel: first values nodeProps

        highlightField: #[
            border: as.code darken to :color bg 0.2
            background: bg
        ]

        return #[
            id: nodeId
            tag: nodeTag
            properties: nodeProps
            label: truncate nodeLabel 10
            fullLabel: nodeLabel
            color: #[
                border: bg
                background: bg
                hover: bg
                highlight: highlightField
            ]
            font: #[
                color: fg
            ]
        ]
    ]

    ;
    ; Get random node color
    ; for graph visualization
    ;--------------------------

    ; addColorForNodeType: function [nn, existingCl][
    ;     if? not? key? nodeConfig nn\tag [
    ;         cl: sample colori
    ;         ; while [contains? existingCl cl][
    ;         ;     cl: sample colori
    ;         ; ]
    ;         cl: to :string cl
    ;         ;print ~"picked |cl|"
    ;         remove 'colori cl
    ;         props: #[
    ;             color: #[
    ;                 border: cl,
    ;                 background: cl,
    ;                 highlight: #[],
    ;                 hover: cl
    ;             ]
    ;             label: get keys nn\properties 0
    ;         ]
    ;         props\color\highlight\border: as.code darken to :color cl 0.2
    ;         props\color\highlight\background: cl

    ;         ;set nodeConfig nn\tag props

    ;         return cl
    ;     ]
    ;     else [
    ;         return null
    ;     ]
    ; ]

    ;
    ; Create new edge
    ;--------------------------

    edge: function [
        src :integer :dictionary 
        name :literal :string
        tgt :integer :dictionary
    ][
        ;; description: Â« create edge from source to target node with given name
        ;; returns: :dictionary

        srcId: src
        tgtId: tgt

        if dictionary? srcId -> srcId: src\id
        if dictionary? tgtId -> tgtId: tgt\id

        edgeId: performQuery.id 'edge createEdgeSQL @[name, srcId, tgtId]

        #[
            id: edgeId
            tag: name
            source: src
            target: tgt
        ]
    ]

    ;
    ; Delete existing edge
    ;--------------------------

    unedge: function [
        src :integer
        name :literal :string
        tgt :integer
    ][
        ;; description: Â« delete edge from source to target node with given name

        performQuery 'unedge deleteEdgeSQL @[name, src, tgt]
    ]

    ;
    ; Delete existing edge 
    ; by id
    ;--------------------------

    unedgeById: function [
        eid :integer
    ][
        ;; description: Â« delete edge with given id

        performQuery 'unedgeById deleteEdgeByIdSQL @[eid]
    ]

    ;
    ; Re-tag existing edge 
    ; by id
    ;--------------------------

    retagEdge: function [
        eid :integer
        tag :literal :string
    ][
        ;; description: Â« update edge with given tag

        performQuery 'retag updateEdgeSQL @[tag, eid]
    ]

    ;
    ; Get node with properties
    ; from ID
    ;--------------------------

    nodeFromId: function [nid][
        results: performQuery 'nodeFromId getNodeSQL @[nid]
        
        if empty? results ->
            return Ã¸ 

        return #[
            id: nid
            tag: first first results
            properties: read.json last first results
        ]
    ]

    ;
    ; Get nodeset 
    ; for graph visualization
    ;--------------------------

    nodeFromIds: function [nodes][
        nodeset: nodes
        if not? block? nodeset ->
            nodeset: @[nodeset]

        nodeElements: map nodeset 'nd -> styleNode nd\id nd\tag nd\properties
        edgeElements: new []

        loop nodeset [nd][
            rezu: performQuery 'nodeFromIds getRelatedNodesSQL @[nd\id, nd\id, nd\id]

            loop rezu [rez][
                'nodeElements ++ styleNode rez\0 rez\1 read.json rez\2
                'edgeElements ++ #[
                    id: ~"|rez\3|+|rez\4|+|rez\5|"
                    dbId: rez\6
                    label: rez\5
                    from: to :integer rez\3
                    to: to :integer rez\4
                ]
            ]
        ]

        unique 'nodeElements
        unique 'edgeElements

        return #[
            nodes: nodeElements
            edges: edgeElements
        ]
    ]

    ;
    ; Generate access helper
    ;--------------------------
    generateHelper: function [id,block][
        if? not? null? attr 'new [
            put id block
        ]
        else [
            fetch id block
        ]
    ]

    ;==========================================
    ; REPL
    ;==========================================

    ;
    ; Switch verbosity on/off
    ;--------------------------

    verbose: function [] [
        Grafito\verbose?: not? Grafito\verbose?
    ]

    ;==========================================
    ; METHODS
    ;==========================================

    ;
    ; Create new node
    ;--------------------------
    
    put: function [
        name :literal :string
        attributes :block :dictionary
    ][
        ;; description: Â« insert new node(s) to graph with given name and attributes
        ;; options: [
        ;;      unique: Â« add only if node doesn't already exist
        ;;      many:Â Â« add multiple nodes at once
        ;; ]
        ;; returns: :dictionary :block

        if attr "unique" [
            found: fetch name attributes
            if not? empty? found -> return found
        ]

        result: new []

        if? not? null? attr 'many [
            lastId: to :integer first first performQuery 'put getMaxNodeIdSQL Ã¸
            queries: new []
            vals: new []
            loop attributes 'nd [
                lastId: lastId + 1
                att: nd
                if not? dictionary? att -> att: # att
                'queries ++ createNodeSQL
                'vals ++ @[name, write.json Ã¸ att]
                'result ++ #[
                    id: lastId
                    tag: name
                    properties: att
                ]
            ]
            performQuery 'put queries vals

            if Grafito\verbose? ->
                 printDebug ~{created |size attributes| nodes}
        ]
        else [
            att: attributes
            if not? dictionary? att -> att: # att
            nodeId: performQuery.id 'put createNodeSQL @[name, write.json Ã¸ att]
            result: #[
                id: nodeId
                tag: name
                properties: att
            ]

            if Grafito\verbose? ->
                printDebug ~{created 1 node (@|nodeId|) with |size att| propert|if? 1 = size att -> "y" else -> "ies"|}
        ]
    
        return result
    ]

    ;
    ; Update existing node
    ;--------------------------

    ; TODO(Grafito\edit) not changing JSON when field has been deleted
    ;  labels: bug,engine,core functions

    edit: function [
        nd :dictionary :block
        attributes :block :dictionary
    ][
        ;; description: Â« update given node(s) with attributes
        ;; options: [
        ;;      tag: :literal :string Â« also set new tag
        ;;      replace: Â« replace entire object properties with given ones
        ;; ]
        ;; returns: :nothing

        toUpdate: Ã¸

        if? dictionary? nd ->
            toUpdate: @[nd]
        else ->
            toUpdate: new nd

        doReplace?: not? null? attr 'replace
        withTag: attr 'tag

        additional: attributes
        if block? additional ->
            additional: # additional

        loop toUpdate 'updateable [
            newAttributes: Ã¸

            if? doReplace? ->
                newAttributes: additional
            else ->
                newAttributes: extend updateable\properties additional

            updateable\properties: newAttributes
            if? null? withTag ->
                performQuery 'edit updateNodePropertiesSQL @[write.json Ã¸ newAttributes, updateable\id]
            else ->
                performQuery 'edit updateNodeSQL @[withTag, write.json Ã¸ newAttributes, updateable\id]
        ]
    ]

    ;
    ; Delete existing node
    ;--------------------------

    unput: function [
        nd :integer :dictionary :block
    ][
        ;; description: Â« remove given node(s) from graph
        ;; returns: :nothing

        toDelete: Ã¸

        if? block? nd ->
            toDelete: new nd
        else ->
            toDelete: @[nd]

        loop toDelete 'deletable [
            nodeId: (dictionary? deletable) ? -> deletable\id -> deletable

            performQuery 'unput @[
                deleteNodeSQL, deleteNodeEdgesSQL
            ] @[
                nodeId, nodeId, nodeId
            ]
        ]
    ]

    ;
    ; Link nodes with edges
    ;--------------------------

    link: function [
        src :block :dictionary
        name :literal :string
        tgt :block :dictionary
    ]
    [
        ;; description: Â« create a connection from source to target node with given name
        ;; returns: :block :dictionary

        edgeId: 0

        if? :dictionary = type tgt [
            edges: new []
            if :dictionary = type src [
                ret: edge src name tgt
                return ret
            ]

            sr: @ src
            loop sr [s]->
                'edges ++ edge s name tgt
        
            if Grafito\verbose? -> printDebug ~"created |size edges| edges"

            return edges
        ]
        else [
            edges: new []
            tg: @ tgt
            if? :dictionary = type src [
                loop tg [t]->
                    'edges ++ edge src name t
            ]
            else [
                sr: @ src
                loop sr [s] [
                    loop tg [t]->
                        'edges ++ edge s name t
                ]
            ]

            if Grafito\verbose? -> printDebug ~"created |size edges| edges"

            return edges
        ]
    ]

    ;
    ; Delete node edges
    ;--------------------------

    unlink: function [
        src :integer :dictionary :block
        name :literal :string
        tgt :integer :dictionary :block
    ][
        ;; description: Â« remove connection from source to target node with given name

        nodesFrom: new []
        nodesTo: new []

        case [(type src)=]
            when? -> :dictionary -> nodesFrom: @[src\id]
            when? -> :integer -> nodesFrom: @[src]
            else  -> nodesFrom: new map src 'n [
                if? dictionary? n -> n\id
                else -> n
            ]

        case [(type tgt)=]
            when? -> :dictionary -> nodesTo: @[tgt\id]
            when? -> :integer -> nodesTo: @[tgt]
            else  -> nodesTo: new map tgt 'n [
                if? dictionary? n -> n\id
                else -> n
            ]

        loop nodesFrom 'nf [
            loop nodesTo 'nt [
                unedge nf name nt
            ]
        ]

        if Grafito\verbose? [
            totalEdges: mul size nodesFrom size nodesTo
            edgeLabel: (totalEdges = 1) ? -> "edge" -> "edges"
            printDebug ~"removed |totalEdges| |edgeLabel|"
        ]
    ]

    ;
    ; Check node type
    ;--------------------------
    
    isA?: function [ls,nd][
        nd\tag = to :string ls
    ]

    ;
    ; Fetch all results for tag
    ; with given properties
    ; and edges
    ;--------------------------

    fetch: function [
        name :literal :string
        attributes :null :string :block :dictionary
    ][
        ;; description: Â« retrieves nodes with name that match all given attributes
        ;; options: [
        ;;      .any Â« try matching any of the attributes
        ;; ]
        ;; returns: :block
        
        ;; setup main variables

        catchAny?: false
        if? not? null? attr "any" ->
            catchAny?: true

        collator: ""
        if not? Grafito\caseSensitive? ->
            collator: " COLLATE NOCASE"

        propertyFilters: new []
        edgeFilters: new []
        qvals: new @[name]
        qpropvals: new []
        qedgevals: new []

        att: new attributes

        if? string? att [
            [collate,symb,val]: @[collator, "=", as.code att]
            
            ; add it once (to check for `name`)
            'propertyFilters ++ ~propertyWithValueFilter
            'qpropvals ++ @[~"$.name"]

            ; add it once more (to check for `title`)
            'propertyFilters ++ ~propertyWithValueFilter
            'qpropvals ++ @[~"$.title"]

            ; we won't it to be valid when any of the two criteria above is true
            ; so we'll have to forcefully set `catchAny?` to true
            catchAny?: true
        ]
        else [
            if and? not? dictionary? att 
                    not? null? att ->
                att: # att

            ; HACK - to solve
            remove.key 'att 'n
            remove.key 'att 'a

            if not? empty? att [
                loop att [k,v][
                    case [equal? type v]
                        when? [:null][
                            ; it's an edge filter without criteria
                            'edgeFilters ++ hasEdgeFilter
                            'qedgevals ++ @[k]
                        ]
                        when? [:dictionary][
                            ; it's an edge filter
                            'edgeFilters ++ edgeWithTargetFilter
                            'qedgevals ++ @[k, v\id]
                        ]
                        when? [:block][
                            if? and? 0 < size v 
                                    :dictionary = type first v [
                                ; it's an array of edge filters
                                orCriteria: new []
                                loop v [edgef][
                                    'orCriteria ++ {!sql (edges.tag=? AND edges.target=?)}
                                    'qedgevals ++ @[k, edgef\id]
                                ]
                                'edgeFilters ++ "(" ++ (join.with:" OR " orCriteria) ++ ")"
                            ]
                            else [
                                ; it's a complex property filter
                                loop #v [filt,rg][

                                    [collate,symb,val]: @[collator, "=", v]

                                    case [equal? filt]
            
                                        when? ["contains"]      -> [collate,symb,val]: @["", "LIKE", ~"%|rg|%"]
                                        when? ["prefix"]        -> [collate,symb,val]: @["", "LIKE", ~"|rg|%"]
                                        when? ["suffix"]        -> [collate,symb,val]: @["", "LIKE", ~"%|rg|"]
                                        when? ["under"]         -> [collate,symb,val]: @["", "<", rg]
                                        when? ["over"]          -> [collate,symb,val]: @["", ">", rg]
                                        when? ["underOrEqual"]  -> [collate,symb,val]: @["", "<=", rg]
                                        when? ["overOrEqual"]   -> [collate,symb,val]: @["", ">=", rg]
                                        when? ["in"]            -> [collate,symb,val]: @[collator, "IN", ~{(|join.with:", " map rg [x]["'" ++ (to :string x) ++ "'"]|)}]
                                        when? ["not"][     
                                            if? block? rg       -> [collate,symb,val]: @[collator, "NOT IN", ~{(|join.with:", " map rg [x]["'" ++ (to :string x) ++ "'"]|)}]
                                            else                -> [collate,symb,val]: @[collator, "!=", rg]
                                        ]
                                        else [
                                            panic.code: 1 ~"filter: |filt| not recognized"
                                        ]
                                    
                                    val: as.code val
                                    'propertyFilters ++ ~propertyWithValueFilter
                                    'qpropvals ++ @[~"$.|k|"]
                                ]
                            ]
                        ]
                        when? [:logical][
                            ; it's a simple property filter without criteria
                            'propertyFilters ++ hasPropertyFilter
                            'qpropvals ++ @[~"$.|k|"]
                        ]
                        else [
                            ; it's a simple property filter
                            [collate,symb,val]: @[collator, "=", as.code v]
            
                            'propertyFilters ++ ~propertyWithValueFilter
                            'qpropvals ++ @[~"$.|k|"]
                        ]
                ]
            ]
        ]

        qr: ""

        propies: ""
        linker: " AND "
        edgeLimit: ~" = |size edgeFilters|"

        if catchAny? [
            linker: " OR "
            edgeLimit: " >= 1"
        ]

        if not? empty? propertyFilters ->
            propies: ~{!sql AND (|join.with: linker propertyFilters|)}
            'qvals ++ qpropvals

        if? not? empty? edgeFilters [
            edgies: join.with: " OR " edgeFilters
            'qvals ++ qedgevals

            qr: ~fetchNodesWithEdgesSQL
        ]
        else [
            qr: ~fetchNodesSQL
        ]

        return map performQuery 'fetch qr qvals 'x [
            #[
                id: x\0
                tag: x\1
                properties: read.json x\2
            ]
        ]
    ]

    ;
    ; Visualize given nodeset
    ;--------------------------

    preview: function [
        nodeset :block
    ][
        ;; description: Â« preview given set of nodes in Grafito's UI
        ;; options: [
        ;;      server: Â« start Grafito as a server
        ;; ]

        currentNodes: new nodeset
        currentDataset: new nodeFromIds currentNodes

        Versions: #[
            engine: to :version first split.by:" " execute "sqlite3 --version"
            system: Grafito\Version
            arturo: strip replace replace execute "arturo -v" "arturo" "" "v/" ""
        ]
        
        routes: #.raw[
            "/"             [
                render.template app
            ]

            "/startup" [
                write.json Ã¸ #[
                    title: cleanpath
                    data: currentDataset
                    rows: currentNodes
                    versions: Versions
                    caseSensitive: Grafito\caseSensitive?
                ]
            ]

            "/exec"         [;[command]
                try? [
                    if Grafito\verbose? ->
                        printDebug "<== " ++ command
                    currentNodes: ""
                    bench: benchmark.get [
                        currentNodes: new do command
                    ]
                    if Grafito\verbose? -> 
                        printDebug ~"==> OK (|bench| ms)"
                    if? or? [not? block? currentNodes]
                            [and? [0 < size currentNodes][not? dictionary? first currentNodes]][
                        "empty"
                    ]
                    else [
                        currentDataset: new nodeFromIds currentNodes
                        write.json Ã¸ #[
                            data: currentDataset
                            rows: currentNodes
                            timeTaken: bench
                        ]
                    ]
                ]
                else [
                    "error"
                ]
            ]

            "/nodeFromId"   [;[ndid]
                newNodes: new nodeFromIds @[nodeFromId ndid]
                write.json Ã¸ newNodes
            ]

            "/deleteNode"   [;[ndid]
                unput to :integer ndid
                ""
            ]

            "/updateNode"   [;[ndid,newtag,props]
                nd: nodeFromId ndid
                edit.replace.tag:newtag nd read.json props
                ""
            ]

            "/createNode"   [;[newtag,props]
                created: put newtag read.json props
                write.json Ã¸ new nodeFromIds created
            ]

            "/linkNodes"    [;[newtag,src,tgt]
                srcid: to :integer src
                tgtid: to :integer tgt
                edge srcid newtag tgtid
                ""
            ]

            "/updateEdge"   [;[egid,newtag]
                eid: to :integer egid
                retagEdge eid newtag
                ""
            ]

            "/deleteEdge" [;[egid]
                edgeParts: split.by:"+" egid
                unlink to :integer edgeParts\0 
                       edgeParts\2 
                       to :integer edgeParts\1
                ""
            ]

            "/updateEngine" [;[caseSensitive]
                if? to :logical caseSensitive [
                    Grafito\caseSensitive?: true
                    performQuery 'main caseSensitiveLikePragma Ã¸
                ]
                else [
                    Grafito\caseSensitive?: false
                    performQuery 'main caseInsensitiveLikePragma Ã¸
                ]
                ""
            ]

            "/analytics" [;[]
                write.json Ã¸ analytics
            ]

            "/styles/app.less"  [
                read "ui/styles/app.less"
            ]

            "/styles/app.css"  [
                read "ui/styles/app.css"
            ]

            "/scripts/app.js" [
                read "ui/scripts/app.js"
            ]

            "/scripts/ace/ace.js" [
                read "ui/scripts/ace/ace.js"
            ]
            
            "/scripts/ace/themes/monokai.js" [
                read "ui/scripts/ace/themes/monokai.js"
            ]

            "/scripts/ace/modes/grafito.js" [
                replace read "ui/scripts/ace/modes/grafito.js" 
                        "CUSTOM_HELPERS" join.with:"|" entities
            ]

            "/exit" [
                printDebug "Shutting down"
                close db
                exit
            ]
        ]

        if? null? attr 'server [
            serve.chrome routes
        ]
        else [
            serve.verbose routes
        ]
    ]

    ;==========================================
    ; INITIALIZATION
    ;==========================================

    ; basic setup
    Grafito\verbose?: not? null? attr 'verbose
    Grafito\caseSensitive?: null? attr 'nocase

    dbPath: ""
    cleanpath: "in-memory"
    dbExisted: false

    if not? null? dbpath [
        cleanpath: extract.filename dbpath
        dbPath: ~"|cleanpath|.db"
        dbExisted: exists? ~"|cleanpath|.db"
    ]

    nodeColors: #[]

    ; define aliases
    alias.infix {~>} 'link

    ; open the database
    printDebug ~"DB = |cleanpath|"
    db: open dbPath

    dbExists?: true

    ; and initialize it
    ; with the given schema (if necessary)
    if? or? not? null? attr "create"
            not? dbExisted [
        dbExists?: false
        printDebug "creating database from scratch"
        performQuery.noDebug 'main schemaSQL Ã¸
        
        metas: #[]

        set metas 'version "undefined"
        set metas 'mode "json"
        set metas 'version Grafito\Version

        put'meta metas
        pop.discard 1
    ] 
    else [
        printDebug "using existing database"
    ]

    ; setup pragmas
    if Grafito\caseSensitive? ->
        performQuery 'main caseSensitiveLikePragma Ã¸

    ; create helpers, if any
    entities: attr "helpers"
    if null? entities -> entities: []
    ei: new 0
    while [ei < size entities].import [
        entity: to :literal entities\[ei]
        let entity function [block] with 'entity -> generateHelper entity block
        inc 'ei
    ]

    ; process body
    result: do body

    ; close the database
    close db

    ; and that was it :)
    return result
]

;--------------------------
; The main entry point
;--------------------------

if standalone? [
    ; helpers & templates

    Versions: #[
        engine: to :version first split.by:" " execute "sqlite3 --version"
        system: script\version
    ]

    BR: "\n"

    logoTxt: read "logo.txt"

    GrafitoHeader: join @[
        print color #magenta replace.regex logoTxt "#(.+)" (color #white "$1") ++ color.keep #magenta ""
        print "  "
        color #gray "-------------------------------------" BR
        color #gray ~"  system: v/|Versions\system|, engine: v/|Versions\engine|" BR
        color #gray "-------------------------------------" BR
    ]

    ; methods

    launchTerminal: function [][
        completions: ["fetch" "put" "unput" "link" "unlink" "edge" "unedge"]
        historyPath: join.path @[path\home ".arturo" "grafito-history.lst"]

        print ""
        print color #orange "## Tip: Type `verbose` to switch info messages on/off"
        print color #orange "## Launching Grafito console - rock on! ðŸ¤˜"
        print ""

        while Ã¸ .import [
            Got: null

            indentation: ""
            
            inp: input .repl
                    .history: historyPath 
                    .complete: completions
                    "$> " 

            while [suffix? inp " "][
                if suffix? strip inp "[" [
                    indentation: indentation ++ "\t"
                ]
                inp: inp ++ input ".. " ++ indentation
            ]

            try?.verbose.import [
                try.verbose.import to :block inp

                StackSize: size stack
                
                if StackSize > 0 		-> Got: pop 1
                if Got <> null 			-> print color #gray ~"=> |Got|"

                print ""
            ]
            else [
                print ""
            ]
        ]
    ]

    ; startup

    print GrafitoHeader

    if 1 < size arg ->
        panic "Too many arguments given!"

    dbInput: Ã¸
    if 1 = size arg -> 
        dbInput: arg\0

    graph dbInput [
        launchTerminal
    ]
]

;==========================================
; This is the end,
; my only friend, the end...
;==========================================